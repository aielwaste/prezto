#
# Z Functions File 
#
# Authors:
#   Andrew Bell <andrewbell8@gmail.com>
#

# zsh man pages
# man zsh
# man zshmisc       # Anything not fitting into the other sections
# man zshexpn         # Zsh command and parameter expansion
# man zshparam        # Zsh parameters
# man zshoptions      # Zsh options
# man zshbuiltins     # Zsh built-in functions
# man zshzle          # Zsh command line editing
# man zshcompwid      # Zsh completion widgets
# man zshcompsys      # Zsh completion system
# man zshcompctl      # Zsh completion control
# man zshmodules      # Zsh loadable modules
# man zshzftpsys      # Zsh built-in FTP client
# man zshall          # Meta-man page containing all of the above

# get man info for zsh function age
function zinfo() {
  info --index-search=$1 zsh
}


#find all files owned by root (u0), world-writable (W), more than 10k in size (Lk+10) and modified during the last hour (m0)
function find_world_writable() {
  ls **/*(u0WLk+10m0)
}


# find all files that don’t have the write permission to group in current directory and all subdirectories
function find_non_writable() {
  ls **/*(.:g-w:)
}


# print out files that dont have extensions
function find_no_ext() {
  printf '%s\n' ^?*.*
  printf '%s\n' ^?*.[^.]*(D)
  ls -d -- ^?*.*(D)
}



# hrefs creates an HTML hyperlink from a URL with modified anchor text
function linkit() {
  PROGNAME=`basename $0`
  url=`cat /dev/clipboard`
  if [ "$PROGNAME" = "href" ] ; then
    href="<a href='$url'>$url"
  elif [ "$PROGNAME" = "hrefs" ] ; then 
    anchortext=${${(C)url//[_-]/ }:t}
    href="<a href='$url'>$anchortext"
  fi
  echo -n $col
  echo $href > /dev/clipboard | more
}

# decisions
# cd to different drive depending on Windows login name
# drive=$([[ "$LOGNAME" != davidr ]] && echo '/o' || echo '/c') # trad way
# cd ${drive}/inetpub/wwwdev/www.some.co.uk/
# drive=${${${LOGNAME:#davidr}:+/o}:-/c}                        # zsh way
# cd ${drive}/inetpub/wwwdev/www.some.co.uk/


# -------------------------------------------------------
# KILLALL
# -------------------------------------------------------
# killall--Sends the specified signal to all processes that match a 
#   specific process name.

# By default it only kills processes owned by the same user, unless
#   you're root. Use -s SIGNAL to specify a signal to send to the process, 
#   -u USER to specify the user, -t TTY to specify a tty, 
#   and -n to only report what should be done, rather than doing it.
function killall() {
  signal="-INT"      # Default signal is an interrupt.
  user=""   tty=""   donothing=0

  while getopts "s:u:t:n" opt; do
    case "$opt" in
        # Note the trick below: the actual 'kill' command wants -SIGNAL 
        #   but we want SIGNAL, so we'll just prepend the '-' below.
      s ) signal="-$OPTARG";              ;;
      u ) if [ ! -z "$tty" ] ; then
             # Logic error: you can't specify a user and a tty device
             echo "$0: error: -u and -t are mutually exclusive." >&2
             exit 1
           fi
           user=$OPTARG;                  ;;
      t ) if [ ! -z "$user" ] ; then
             echo "$0: error: -u and -t are mutually exclusive." >&2
             exit 1
           fi
           tty=$2;                        ;;
      n ) donothing=1;                    ;;
      ? ) echo "Usage: $0 [-s signal] [-u user|-t tty] [-n] pattern" >&2
          exit 1
    esac
  done

  # Done with processing all the starting flags with getopts...
  shift $(( $OPTIND - 1 ))

  # If the user doesn't specify any starting arguments (earlier test is for -?)
  if [ $# -eq 0 ] ; then
    echo "Usage: $0 [-s signal] [-u user|-t tty] [-n] pattern" >&2
    exit 1
  fi

  # Now we need to generate a list of matching process IDs, either based on 
  #   the specified tty device, the specified user, or the current user.

  if [ ! -z "$tty" ] ; then
    pids=$(ps cu -t $tty | awk "/ $1$/ { print \$2 }")
  elif [ ! -z "$user" ] ; then
    pids=$(ps cu -U $user | awk "/ $1$/ { print \$2 }")
  else
    pids=$(ps cu -U ${USER:-LOGNAME} | awk "/ $1$/ { print \$2 }")
  fi

  # No matches? That was easy!
  if [ -z "$pids" ] ; then
    echo "$0: no processes match pattern $1" >&2; exit 1
  fi

  for pid in $pids
  do
    # Sending signal $signal to process id $pid: kill might still complain
    #   if the process has finished, the user doesn't have permission to kill
    #   the specific process, etc., but that's okay. Our job, at least, is done.
    if [ $donothing -eq 1 ] ; then
      echo "kill $signal $pid"   # the –n flag: "show me, but don't do it"
    else
      kill $signal $pid
    fi
  done

  exit 0
}

# to7z: converts 
#
# Fr1v
# Andrew Bell <andrewbell8@gmail.com>
#
function Cto7z() {
  setopt LOCAL_OPTIONS EXTENDED_GLOB

  for f in "$@"
  do
    local file_ext=${f:e}
    arepack -F.7z -O-m0=lzma2 -O-mx=9 -O-mfb=64 -O-md=32m -O-ms=on -q -e "$f"
    rm "${f:r}.${file_ext}"
    mv "${f:r}.7z" "/Volumes/Installs/macos"
  done
  unset LOCAL_OPTIONS EXTENDED_GLOB
}

function Pto7z() {
  setopt LOCAL_OPTIONS EXTENDED_GLOB

  for f in "$@"
  do
    local file_ext=${f:e}
    apack -F.7z -O-m0=lzma2 -O-mx=9 -O-mfb=64 -O-md=32m -O-ms=on -q -e "$f"
    rm "${f}"
    mv "${f:r}.7z" "/Volumes/Installs/macos"
  done
  unset LOCAL_OPTIONS EXTENDED_GLOB
}